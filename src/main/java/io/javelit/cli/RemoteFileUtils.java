/*
 * Copyright © 2025 Cyril de Catheu (cdecatheu@hey.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.javelit.cli;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import com.fasterxml.jackson.databind.JsonNode;
import io.javelit.core.Shared;
import jakarta.annotation.Nonnull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.google.common.base.Preconditions.checkArgument;

// CAUTION - generated by claude code - surface-level reviewed
class RemoteFileUtils {

    private static final Logger LOG = LoggerFactory.getLogger(RemoteFileUtils.class);
    public static final String INVALID_URL_MESSAGE = """
            Invalid URL format. The URL should be either:
            (1) A direct link to a text/plain .java file (e.g., https://raw.githubusercontent.com/user/repo/branch/file.java)
            (2) A GitHub repository URL (e.g., https://github.com/user/repo)
            (3) A GitHub folder tree URL (e.g., github.com/user/repo/tree/branch/path/to/folder)
            (4) A GitHub file blob URL (e.g., github.com/javelit/javelit/blob/main/examples/Callbacks.java)
            Got: %s
            """;

    static Path downloadRemoteFile(@Nonnull String url, final @Nonnull Path targetDir) throws IOException {
        if (isGitHubUiWebsite(url)) {
            if (isGitHubTreeUrl(url)) {
                return downloadGitHubFolder(url, targetDir);
            } else if (isGitHubBlob(url)) {
                url = convertBlobToRaw(url);
            } else if (isPlainGitHubRepoUrl(url)) {
                // Convert plain repo URL to tree URL with default branch
                url = convertPlainRepoToTreeUrl(url);
                return downloadGitHubFolder(url, targetDir);
            } else {
                throw new IllegalArgumentException(INVALID_URL_MESSAGE);
            }
        }
        final String fileSuffix = getFileSuffix(url);
        if (fileSuffix != null) {
            checkArgument(".java".equals(fileSuffix),
                          "Unsupported file type: %s. Only .java files are supported. " + "If you're trying to run a Java file, make sure the URL ends with .java",
                          fileSuffix);
            return downloadSingleFile(url, targetDir);
        }
        throw new IllegalArgumentException(INVALID_URL_MESSAGE);
    }

    // assuming isGitHubUiWebsite is true
    private static boolean isGitHubTreeUrl(final @Nonnull String url) {
        return url.contains("/tree/");
    }

    private static boolean isGitHubBlob(final @Nonnull String url) {
        return url.contains("/blob/");
    }

    private static boolean isGitHubUiWebsite(final @Nonnull String url) {
        return url.startsWith("https://github.com/");
    }

    /**
     * Check if URL is a plain GitHub repo URL (without /tree/ or /blob/)
     * e.g., https://github.com/owner/repo
     */
    private static boolean isPlainGitHubRepoUrl(final @Nonnull String url) {
        // Match https://github.com/owner/repo with optional trailing slash
        final Pattern pattern = Pattern.compile("https://github\\.com/([^/]+)/([^/]+)/?$");
        return pattern.matcher(url).matches();
    }

    /**
     * Convert plain repo URL to tree URL with default branch (main)
     * e.g., https://github.com/owner/repo -> https://github.com/owner/repo/tree/main
     */
    private static @Nonnull String convertPlainRepoToTreeUrl(final @Nonnull String url) throws IOException {
        // Remove trailing slash if present
        final String cleanUrl = url.endsWith("/") ? url.substring(0, url.length() - 1) : url;

        // Parse owner and repo from URL
        final Pattern pattern = Pattern.compile("https://github\\.com/([^/]+)/([^/]+)$");
        final Matcher matcher = pattern.matcher(cleanUrl);

        if (!matcher.matches()) {
            throw new IOException("Invalid GitHub repo URL format: " + url);
        }

        final String owner = matcher.group(1);
        final String repo = matcher.group(2);

        // Get default branch from GitHub API
        final String defaultBranch = getDefaultBranch(owner, repo);

        return cleanUrl + "/tree/" + defaultBranch;
    }

    /**
     * Get the default branch for a GitHub repository using the API
     */
    private static String getDefaultBranch(final @Nonnull String owner, final @Nonnull String repo) throws IOException {
        try (final HttpClient client = HttpClient.newHttpClient()) {
            final String apiUrl = String.format("https://api.github.com/repos/%s/%s", owner, repo);
            final HttpRequest request = HttpRequest
                    .newBuilder()
                    .uri(URI.create(apiUrl))
                    .header("Accept", "application/vnd.github.v3+json")
                    .build();

            final HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                LOG.warn("Failed to get default branch from GitHub API, falling back to 'main'. Status: {}", response.statusCode());
                return "main"; // Fallback to main
            }

            final JsonNode repoInfo = Shared.OBJECT_MAPPER.readTree(response.body());
            final JsonNode defaultBranchNode = repoInfo.get("default_branch");

            if (defaultBranchNode != null && !defaultBranchNode.isNull()) {
                return defaultBranchNode.asText();
            }

            return "main"; // Fallback
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IOException("Request interrupted", e);
        } catch (Exception e) {
            LOG.warn("Error getting default branch from GitHub API, falling back to 'main'", e);
            return "main"; // Fallback
        }
    }

    /**
     * Convert GitHub blob URL to raw.githubusercontent.com URL
     * e.g., https://github.com/owner/repo/blob/branch/path/file.java
     * -> https://raw.githubusercontent.com/owner/repo/branch/path/file.java
     */
    private static @Nonnull String convertBlobToRaw(final @Nonnull String url) {
        return url.replace("github.com", "raw.githubusercontent.com")
                  .replace("/blob/", "/");
    }

    /**
     * Extract file suffix from URL (e.g., ".java", ".py")
     * Returns null if URL doesn't appear to have a file suffix
     */
    private static String getFileSuffix(final @Nonnull String url) {
        final String path = url.split("\\?")[0]; // Remove query parameters
        final int lastSlash = path.lastIndexOf('/');
        final String lastSegment = lastSlash >= 0 ? path.substring(lastSlash + 1) : path;

        // Check if last segment has a dot (indicating file extension)
        final int lastDot = lastSegment.lastIndexOf('.');
        if (lastDot > 0 && lastDot < lastSegment.length() - 1) {
            return lastSegment.substring(lastDot);
        }
        return null;
    }

    private static Path downloadSingleFile(final @Nonnull String url, final @Nonnull Path targetDir) throws IOException {
        final String filename = extractFilename(url);
        final Path targetFile = targetDir.resolve(filename);
        LOG.info("Downloading {} to {}", url, targetFile);
        try (InputStream in = URI.create(url).toURL().openStream()) {
            Files.copy(in, targetFile, StandardCopyOption.REPLACE_EXISTING);
        }
        LOG.info("Successfully downloaded file to {}", targetFile);
        return targetFile;
    }

    private static String extractFilename(final @Nonnull String path) {
        // Get the path part of the URL
        int lastSlash = path.lastIndexOf('/');
        if (lastSlash >= 0 && lastSlash < path.length() - 1) {
            return path.substring(lastSlash + 1);
        }
        // Fallback to a default name if we can't extract - note cyril: depending on javac this may result in bugs ?
        return "App.java";
    }

    private static Path downloadGitHubFolder(final @Nonnull String url, final @Nonnull Path targetDir) throws IOException {
        LOG.info("Detected GitHub folder URL, downloading entire folder...");

        // Parse GitHub URL to get API endpoint
        final GitHubRepoInfo repoInfo = parseGitHubUrl(url);
        final String apiUrl = String.format("https://api.github.com/repos/%s/%s/contents/%s?ref=%s",
                                            repoInfo.owner,
                                            repoInfo.repo,
                                            repoInfo.path,
                                            repoInfo.branch);

        // Download folder contents
        LOG.info("Downloading folder contents to {}", targetDir);
        downloadGitHubFolderRecursive(apiUrl, targetDir);
        LOG.info("Successfully downloaded folder contents");

        // Find the main Java file
        final Path mainFile = findMainJavaFile(targetDir);
        LOG.info("Found main file: {}", mainFile);
        return mainFile;
    }

    private record GitHubRepoInfo(String owner, String repo, String branch, String path) {
    }

    /**
     * Parse GitHub URL to extract owner, repo, branch, and path
     * Supports URLs like:
     * - https://github.com/owner/repo/tree/branch/path/to/folder
     * - https://github.com/owner/repo/tree/branch (root of branch)
     */
    private static GitHubRepoInfo parseGitHubUrl(final @Nonnull String url) throws IOException {
        final Pattern pattern = Pattern.compile("https://github\\.com/([^/]+)/([^/]+)/tree/([^/]+)(?:/(.*))?");
        final Matcher matcher = pattern.matcher(url);

        if (!matcher.matches()) {
            throw new IOException("Invalid GitHub folder URL format. Expected format: " + "https://github.com/owner/repo/tree/branch[/path/to/folder]");
        }

        final String path = matcher.group(4);
        return new GitHubRepoInfo(matcher.group(1),  // owner
                                  matcher.group(2),  // repo
                                  matcher.group(3),  // branch
                                  path != null && !path.isEmpty() ? path : ""   // path (empty string for root)
        );
    }

    private static void downloadGitHubFolderRecursive(final @Nonnull String apiUrl,
                                                      final @Nonnull Path targetDir) throws IOException {
        try (final HttpClient client = HttpClient.newHttpClient()) {
            final HttpRequest request = HttpRequest
                    .newBuilder()
                    .uri(URI.create(apiUrl))
                    .header("Accept", "application/vnd.github.v3+json")
                    .build();

            final HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                throw new IOException(String.format("GitHub API request failed with status %d: %s",
                                                    response.statusCode(),
                                                    response.body()));
            }
            final JsonNode items = Shared.OBJECT_MAPPER.readTree(response.body());
            if (!items.isArray()) {
                throw new IOException("GitHub API response is not an array. URL might not be a folder.");
            }
            Files.createDirectories(targetDir);
            for (final JsonNode item : items) {
                final String type = item.get("type").asText();
                final String name = item.get("name").asText();

                if ("file".equals(type)) {
                    final String downloadUrl = item.get("download_url").asText();
                    final Path targetFile = targetDir.resolve(name);
                    LOG.debug("Downloading file: {} to {}", name, targetFile);

                    try (InputStream in = URI.create(downloadUrl).toURL().openStream()) {
                        Files.copy(in, targetFile, StandardCopyOption.REPLACE_EXISTING);
                    }
                } else if ("dir".equals(type)) {
                    final String subDirUrl = item.get("url").asText();
                    final Path subDir = targetDir.resolve(name);
                    LOG.debug("Downloading subdirectory: {}", name);
                    downloadGitHubFolderRecursive(subDirUrl, subDir);
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IOException("Download interrupted", e);
        }
    }

    /**
     * Find the main Java file in a folder following these rules:
     * 1. If exactly 1 .java file in root → return it
     * 2. Else if App.java exists → return it
     * 3. Else if Main.java exists → return it
     * 4. Else → throw error
     */
    private static Path findMainJavaFile(final @Nonnull Path folderPath) throws IOException {
        final List<Path> javaFiles = new ArrayList<>();

        try (Stream<Path> stream = Files.list(folderPath)) {
            stream
                    .filter(Files::isRegularFile)
                    .filter(p -> p.getFileName().toString().endsWith(".java"))
                    .forEach(javaFiles::add);
        }
        if (javaFiles.size() == 1) {
            return javaFiles.getFirst();
        }
        final Path appJava = folderPath.resolve("App.java");
        if (Files.exists(appJava)) {
            return appJava;
        }
        final Path mainJava = folderPath.resolve("Main.java");
        if (Files.exists(mainJava)) {
            return mainJava;
        }

        // No suitable file found
        throw new IllegalArgumentException(String.format("Could not determine main Java file in downloaded folder. " + "Found %d .java files in root. " + "When running from a remote github folder, there should be either: " + "(1) exactly 1 .java file in the root directory, or " + "(2) a file named App.java, or " + "(3) a file named Main.java",
                                                         javaFiles.size()));
    }

    private RemoteFileUtils() {
    }
}
