{{!
    Copyright © 2025 Cyril de Catheu (cdecatheu@hey.com)

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
}}
<!DOCTYPE html>
<html>
<head>
    <title>Javelit App</title>
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
    <link rel="preload" as="style" href="{{ MATERIAL_SYMBOLS_CDN }}">
    <link rel="stylesheet" href="{{ MATERIAL_SYMBOLS_CDN }}">
    <link rel="alternate" type="application/json+oembed" href="/_/oembed?url={{ENCODED_CURRENT_URL}}&format=json"
    title="Javelit App">
    {{> design_system.html.mustache }}
    <style>
        html, body {
            height: 100%;
        }

        body {
            font-family: var(--jt-font-family);
            margin: 0;
            background-color: var(--jt-bg-primary);
            color: var(--jt-text-primary);
            line-height: var(--jt-line-height-normal);
        }

        .app-wrapper {
            display: flex;
            height: 100vh;
            gap: var(--jt-spacing-lg);
        }

        .layout-container {
            background: var(--jt-bg-primary);
            padding: var(--jt-spacing-xl);
            padding-bottom: 0;
            padding-top: 0;
            overflow-y: auto;
            overflow-x: hidden;
            height: 100%;
            flex: 1;
            min-width: 0; /* Allow shrinking */
        }

        .main-layout {
            /* TODO make this configurable */
            max-width: 768px;
            margin: 0 auto;

            /* likely people will ask for this - first child margin
            :first-child {
                margin-top: 0;
            }
            */
        }

        .toolbar {
            min-height: 3.25rem;
            background: var(--jt-bg-primary);
            margin: 0 0;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: var(--jt-spacing-md);
            padding: 0 var(--jt-spacing-lg);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .full-sidebar {
            display: block;
            width: 256px;
            flex-shrink: 0;
            background: var(--jt-bg-secondary);
            position: relative;
            transition: width var(--jt-transition-normal);
            padding: 0 var(--jt-spacing-xl);
            overflow-y: auto;
            height: 100%;
        }

        /* Hide entire sidebar when content is empty */
        .full-sidebar:has(.sidebar-content:empty) {
            display: none;
        }

        /* Fallback for browsers without :has() support */
        @supports not (selector(:has(*))) {
            .sidebar-content:empty {
                display: none;
            }

            .sidebar-content:empty + * {
                display: none;
            }
        }

        /* Collapsed state */
        .full-sidebar.collapsed {
            width: 24px;
            background-color: var(--jt-bg-primary);
            overflow-y: hidden;
        }

        /* Sidebar tooling (chevron area) */
        .sidebar-tooling {
            display: flex;
            justify-content: right;
            padding-top: var(--jt-spacing-md);
        }

        /* Collapse button */
        .collapse-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            border-radius: var(--jt-border-radius-lg);
            color: var(--jt-text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all var(--jt-transition-fast);
        }

        .collapse-btn:hover {
            background: var(--jt-bg-tertiary);
            color: var(--jt-text-primary);
        }

        /* Hide chevron by default when sidebar is expanded */
        .full-sidebar:not(.collapsed) .collapse-btn {
            opacity: 0;
            transition: opacity var(--jt-transition-fast);
        }

        /* Show chevron on hover when sidebar is expanded */
        .full-sidebar:not(.collapsed):hover .collapse-btn {
            opacity: 1;
        }

        /* Always show chevron when collapsed */
        .full-sidebar.collapsed .collapse-btn {
            opacity: 1;
        }

        /* Rotate chevron when collapsed */
        .full-sidebar.collapsed .collapse-btn .material-symbols-rounded {
            transform: rotate(180deg);
        }

        /* Hide content when collapsed, but keep tooling visible */
        .full-sidebar.collapsed .sidebar-content {
            opacity: 0;
            pointer-events: none;
        }

        /* Resize handle for dragging sidebar width */
        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: -3px;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            background: transparent;
            z-index: 20;
            transition: background-color var(--jt-transition-fast);
        }

        .sidebar-resize-handle:hover {
            background: var(--jt-border-color);
        }

        /* Hide handle when sidebar is collapsed */
        .full-sidebar.collapsed .sidebar-resize-handle {
            display: none;
        }

        /* Prevent text selection during resize */
        body.resizing {
            user-select: none;
            cursor: col-resize;
        }

        .loading-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--jt-spacing-md);
            height: 200px;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--jt-border-color);
            border-top-color: var(--jt-theme-active);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            font-family: var(--jt-font-family);
            font-size: var(--jt-font-size-sm);
            color: var(--jt-text-secondary);
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes errorPulse {
            0% {
                box-shadow: 0 0 0 0 var(--jt-theme-color);
            }
            50% {
                box-shadow: 0 0 0 4px var(--jt-theme-color);
            }
            100% {
                box-shadow: 0 0 0 0 var(--jt-theme-color);
            }
        }

        .error-updated {
            border-radius: var(--jt-border-radius-lg);
            animation: errorPulse 0.6s linear 3;
        }

        .javelit-attribution {
            position: fixed;
            bottom: 0;
            right: 0;
            z-index: 500;
            font-family: var(--jt-font-family);
            font-size: var(--jt-font-size-xs);
            color: var(--jt-text-white);
            text-decoration: none;
            transition: color var(--jt-transition-fast);
            background-color: var(--jt-theme-color);
            padding: var(--jt-spacing-sm) var(--jt-spacing-md);
            border-radius: var(--jt-border-radius) 0 0 0;
        }

        .javelit-attribution:hover {
            font-weight: var(--jt-font-weight-bold);
            padding: var(--jt-spacing-sm) var(--jt-spacing-sm);
        }

        /* Embed mode styles - activated when ?embed=true */
        #root {
            /* Transparent container in normal mode */
        }

        body.embed-mode {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll */
        }

        body.embed-mode #root {
            display: flex;
            flex-direction: column;
            height: 100vh;
            border: 3px solid var(--jt-bg-tertiary);
            border-radius: 0.75rem;
            overflow: hidden;
        }

        body.embed-mode .app-wrapper {
            flex: 1;
            overflow-y: auto; /* Single scrollbar inside the border */
            overflow-x: hidden;
        }

        /* Embed footer - hidden by default, shown in embed mode */
        .embed-footer {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--jt-bg-tertiary);
            font-size: 14px;
            color: var(--jt-text-secondary);
            font-family: var(--jt-font-family);
        }

        body.embed-mode .embed-footer {
            display: flex;
        }

        .embed-footer a {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--jt-text-secondary);
            text-decoration: none;
        }

        .embed-footer a:hover .link-text {
            text-decoration: underline;
        }

        .embed-footer .material-symbols-rounded {
            font-size: 16px;
        }
    </style>
    {{{ customHeaders }}}
    {{> tooltip.html.mustache }}
    {{> connection-error-modal.html.mustache }}
    {{> toast.html.mustache }}
    {{> code.html.mustache }}
    {{> toolbar-menu.html.mustache }}
    {{> status-widget.html.mustache }}
    {{> deploy-button.html.mustache }}
    {{> settings-content.html.mustache }}
    {{! one-liner svg favicon }}
    <link rel="icon"
          href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20style%3D%22transform%3A%20scale%28-1%2C1%29%22%3E%0A%20%20%3Ctext%20y%3D%2232%22%20font-size%3D%2232%22%3E%F0%9F%9A%A1%3C%2Ftext%3E%0A%3C%2Fsvg%3E">
</head>
<body>
<div id="root">
    <div id="app" class="app-wrapper">
        {{! Sidebar with separated UI chrome and content }}
        <div id="full-sidebar" class="full-sidebar">
            <div id="sidebar-tooling" class="sidebar-tooling">
                <button id="collapse-btn" class="collapse-btn" aria-label="Toggle sidebar">
                    <span class="material-symbols-rounded">keyboard_double_arrow_left</span>
                </button>
            </div>
            {{! make sure this stays empty with no spaces - it uses the :empty selector to hide if there is nothing inside }}
            <div id="sidebar-container" class="sidebar-content" data-container="sidebar"></div>
        </div>
        <div class="layout-container">
            <div class="toolbar">
                <jt-status-widget id="status-widget"></jt-status-widget>
                <jt-deploy-button id="deploy-button"></jt-deploy-button>
                <jt-toolbar-menu id="toolbar-menu"></jt-toolbar-menu>
            </div>
            <div id="main-container" class="main-layout" data-container="main">
                <div id="loading-placeholder" class="loading-state">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Loading...</div>
                </div>
            </div>
        </div>
    </div>
</div>

{{! Connection Error Modal }}
<jt-connection-error-modal id="connection-modal" prevent-close>
    <span slot="title">Connection Error</span>
    <p>Unable to connect to the Javelit server.</p>
    {{#DEV_MODE }}
        <p>If you accidentally stopped Javelit, just restart it in your terminal:</p>
        <jt-internal-code body="javelit run YourApp.java" language="bash"></jt-internal-code>
    {{/DEV_MODE}}
    {{^DEV_MODE }}
        <p>Retrying in a few seconds...</p>
    {{/DEV_MODE}}
</jt-connection-error-modal>


{{! Any other error modal }}
<jt-connection-error-modal id="other-error-modal">
    <span id="other-error-title" slot="title">Compilation error</span>
    <p id="other-error-paragraph">Fix the compilation errors below and save the file to continue:</p>
    <jt-internal-code id="other-error-code" body=""></jt-internal-code>
</jt-connection-error-modal>

{{! Settings Modal }}
<jt-connection-error-modal id="settings-modal" top-aligned>
    <span slot="title">Settings</span>
    <jt-settings-content></jt-settings-content>
</jt-connection-error-modal>

{{! Deploy Modal }}
<jt-connection-error-modal id="deploy-modal" top-aligned>
    <h3 slot="title">Deploy this app using...</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--jt-spacing-lg); margin-top: var(--jt-spacing-md);">
        <div style="padding: var(--jt-spacing-md); border: 1px solid #A020F0; border-radius: var(--jt-border-radius); box-shadow: 0 0 8px rgba(160, 32, 240, 0.4), 0 0 16px rgba(160, 32, 240, 0.2);">
            <h3 style="margin: 0 0 var(--jt-spacing-sm) 0;">
                Railway
            </h3>
            <p style="margin: 0 0 var(--jt-spacing-md) 0;">Deploy your app in one click - free tier included and scales
                down to zero automatically.</p>
            <a href="{{ RAILWAY_DEPLOY_APP_URL }}" target="_blank" rel="noopener noreferrer">
                <img src="https://railway.com/button.svg" alt="Deploy on Railway">
            </a>
            <details style="font-size: var(--jt-font-size-sm)">
                <summary><i>Deploying with Railway supports the Javelit project!</i></summary>
                <i>The interactive examples in the documentation are hosted on Railway. <br>Deploying your Javelit apps
                    with this Railway template sends 25% of your spend back to Javelit to help fund the hosting.</i>
            </details>
        </div>
        <div style="padding: var(--jt-spacing-md); border: 1px solid var(--jt-border-color); border-radius: var(--jt-border-radius);">
            <h3 style="margin: 0 0 var(--jt-spacing-sm) 0;">Custom Deployment</h3>
            <p style="margin: 0;">For other platforms and custom deployments, <a href="https://docs.javelit.io/deploy"
                                                                                 target="_blank">refer to the
                documentation</a></p>
        </div>
    </div>
</jt-connection-error-modal>

{{! Attribution }}
<a href="https://github.com/javelit/javelit" class="javelit-attribution" target="_blank" rel="noopener">&hearts; Built
    with Javelit &hearts;</a>

<script>
    const app = document.getElementById('app');
    const mainContainer = document.getElementById('main-container');
    const fullSidebar = document.getElementById('full-sidebar');
    const sidebarContainer = document.getElementById('sidebar-container');
    const collapseBtn = document.getElementById('collapse-btn');
    const connectionModal = document.getElementById('connection-modal');
    const otherErrorModal = document.getElementById('other-error-modal');
    const statusWidget = document.getElementById('status-widget');
    const settingsContent = document.querySelector('jt-settings-content');
    const mainLayout = document.querySelector('.main-layout');

    // Track if this is the first message to clear connecting text
    let isFirstDelta = true;

    // Localhost detection and XSRF token - available globally
    window.javelit = {
        isDevMode: {{ DEV_MODE }},
        isStandaloneMode: {{ STANDALONE_MODE }},
        xsrfToken: "{{ XSRF_TOKEN }}",
        baseUrlPath: "{{ BASE_URL_PATH }}"
    };

    // Embed mode detection and setup
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('embed') === 'true') {
        // Activate embed mode styling
        document.body.classList.add('embed-mode');

        // Create and inject embed footer
        const footer = document.createElement('div');
        footer.className = 'embed-footer';

        // Get current URL without embed parameter for fullscreen link
        const fullscreenUrl = window.location.href
                .replace(/[?&]embed=true/g, '')
                .replace(/\?&/, '?')  // Fix malformed query string
                .replace(/\?$/, '');   // Remove trailing ?

        footer.innerHTML = `
            <span>Built with <a href="https://javelit.io" target="_blank"><span class="link-text">Javelit</span></a></span>
            <a href="${fullscreenUrl}" target="_blank">
                <span class="link-text">Fullscreen</span>
                <span class="material-symbols-rounded">open_in_new</span>
            </a>
        `;

        // Insert footer inside the root container (after the app div)
        app.parentElement.appendChild(footer);
    }
    if (window.javelit.isDevMode || urlParams.get('embed') === 'true') {
        document.querySelector('.javelit-attribution').style.display = 'none';
    }

    // Connection management
    let ws = null;
    let connectionState = 'disconnected'; // 'connected', 'disconnected', 'reconnecting'

    // Sidebar collapse state management
    let sidebarCollapsed = localStorage.getItem('javelit-sidebar-collapsed') === 'true';

    // Sidebar resize state
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    let animationFrameId = null;
    const MIN_SIDEBAR_WIDTH = 150;
    const MAX_SIDEBAR_WIDTH = 500;
    const DEFAULT_SIDEBAR_WIDTH = 256;

    function initializeSidebar() {
        if (sidebarCollapsed) {
            fullSidebar.classList.add('collapsed');
        } else {
            // Restore saved width if not collapsed
            const savedWidth = localStorage.getItem('javelit-sidebar-width');
            if (savedWidth) {
                fullSidebar.style.width = savedWidth + 'px';
            }
        }

        collapseBtn.addEventListener('click', toggleSidebarCollapse);

        // Enable resize functionality
        enableSidebarResize();
    }

    function enableSidebarResize() {
        // Create resize handle
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'sidebar-resize-handle';
        fullSidebar.appendChild(resizeHandle);

        // Mouse events
        resizeHandle.addEventListener('mousedown', initResize);

        // Touch events for mobile
        resizeHandle.addEventListener('touchstart', initResize, {passive: false});
    }

    function initResize(e) {
        if (sidebarCollapsed) return;

        isResizing = true;
        startX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        startWidth = parseInt(getComputedStyle(fullSidebar).width, 10);

        // Disable transition during drag to prevent lag
        fullSidebar.style.transition = 'none';

        document.body.classList.add('resizing');

        // Add listeners to document for drag/end
        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);
        document.addEventListener('touchmove', doResize, {passive: false});
        document.addEventListener('touchend', stopResize);

        e.preventDefault();
    }

    function doResize(e) {
        if (!isResizing) return;

        // Cancel previous frame if pending
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }

        // Use requestAnimationFrame for smooth updates
        animationFrameId = requestAnimationFrame(() => {
            const currentX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const newWidth = Math.min(MAX_SIDEBAR_WIDTH, Math.max(MIN_SIDEBAR_WIDTH, startWidth + currentX - startX));

            fullSidebar.style.width = newWidth + 'px';
            animationFrameId = null;
        });

        e.preventDefault();
    }

    function stopResize(e) {
        if (!isResizing) return;

        isResizing = false;
        document.body.classList.remove('resizing');

        // Cancel any pending animation frame
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        // Re-enable transition after drag
        fullSidebar.style.transition = '';

        // Save width
        if (!sidebarCollapsed) {
            const currentWidth = fullSidebar.offsetWidth;
            localStorage.setItem('javelit-sidebar-width', currentWidth);
        }

        // Remove document listeners
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopResize);
        document.removeEventListener('touchmove', doResize);
        document.removeEventListener('touchend', stopResize);
    }

    function toggleSidebarCollapse() {
        sidebarCollapsed = !sidebarCollapsed;

        if (sidebarCollapsed) {
            // Save current width before collapsing
            const currentWidth = fullSidebar.offsetWidth;
            if (currentWidth > 24) {
                localStorage.setItem('javelit-sidebar-expanded-width', currentWidth);
            }
            fullSidebar.classList.add('collapsed');
            fullSidebar.style.width = '24px';
        } else {
            // Restore saved width when expanding
            fullSidebar.classList.remove('collapsed');
            const savedWidth = localStorage.getItem('javelit-sidebar-expanded-width') ||
                    localStorage.getItem('javelit-sidebar-width') ||
                    DEFAULT_SIDEBAR_WIDTH;
            fullSidebar.style.width = savedWidth + 'px';
        }

        // Store state in localStorage
        localStorage.setItem('javelit-sidebar-collapsed', sidebarCollapsed.toString());
    }

    window.javelit = {
        ...window.javelit,
        sendComponentUpdate: function (componentKey, value) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'component_update',
                    componentKey: componentKey,
                    value: value
                }));
            } else {
                console.log("Failed to send update to backend. Connection to backend is not available.");
            }
        },
        sendPathUpdate: function () {
            // Parse query parameters using URLSearchParams
            const params = new URLSearchParams(window.location.search);
            const queryObj = {};
            for (const key of params.keys()) {
                queryObj[key] = params.getAll(key);
            }

            // Strip base path from pathname before sending to backend
            const basePath = this.baseUrlPath;
            let relativePath;
            if (basePath) {
                relativePath = window.location.pathname.substring(basePath.length);
                // basePath contains the root "/" - we need to keep it in the case were in the home page
                if (relativePath === '') {
                    relativePath = '/';
                }
            } else {
                relativePath = window.location.pathname;
            }

            // Send path_update message to backend to trigger app re-run
            window.javelit.sendMessage({
                type: 'path_update',
                path: relativePath,
                queryParameters: queryObj,
            });
        },
        sendMessage: function (message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                console.log("Failed to send message to backend. Connection to backend is not available.");
            }
        },
        prependBasePath: function (url) {
            if (!url) return url;
            const basePath = this.baseUrlPath || '';
            if (!basePath || url.startsWith('http://') || url.startsWith('https://') ||
                    url.startsWith('data:') || url.startsWith('blob:')) {
                return url;
            }
            // relative path - we need to add the basePath
            // a relative url may be passed without / for static files - NOTE: for the moment this logic is string based because it is not meant to support all url path build edge cases
            const normalizedUrl = url.startsWith('/') ? url : '/' + url;
            return basePath + normalizedUrl;
        },
    };

    // Connection management functions
    function createWebSocketConnection() {
        try {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const basePath = window.javelit.baseUrlPath;
            const wsUrl = new URL(basePath + '/_/ws', window.location.origin);
            wsUrl.protocol = protocol;
            ws = new WebSocket(wsUrl);

            ws.onclose = () => {
                console.log('WebSocket closed');
                handleConnectionLoss();
            };

            ws.onmessage = handleWebSocketMessage;

            ws.onopen = () => {
                window.javelit.sendPathUpdate();
                connectionState = 'connected';
                console.log('WebSocket connected');
                connectionModal.show = false;
                otherErrorModal.show = false;
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

        } catch (error) {
            console.error('Failed to create WebSocket:', error);
            handleConnectionLoss();
        }
    }

    function handleConnectionLoss() {
        if (connectionState === 'connected') {
            // First time losing connection - show the connection lost modal
            // wait 1s to avoid modal flickerings when a page is reloaded
            setTimeout(() => {
                connectionModal.show = true;
            }, 1000)
        }
        connectionState = 'reconnecting';
        setTimeout(() => {
            console.log('Attempting to reconnect...');
            createWebSocketConnection();
        }, 5000);

        // Clear websocket references
        ws = null;
    }

    async function handleWebSocketMessage(event) {
        const message = JSON.parse(event.data);
        if (message.type === 'session_init') {
            // Store WebSocket session ID for POST/PUT requests - eg file uploads
            window.javelit.sessionId = message.sessionId;
        } else if (message.type === 'delta') {
            handleDeltaMessage(message);
        } else if (message.type === 'modal_error') {
            handleModalErrorMessage(message)
        } else if (message.type === 'status') {
            if (statusWidget) {
                // TODO: This await is a workaround for a race condition. The custom element
                // (jt-status-widget) is defined asynchronously via type="module" script, but
                // this code runs before the element is upgraded. A better fix would be to load
                // the custom element synchronously or restructure the script loading order.
                await customElements.whenDefined('jt-status-widget');
                statusWidget.updateStatus(message.status);
            }
            if (message.status === "BEGIN") {
                otherErrorModal.show = false;
            }
            if (message.status === "END" && isFirstDelta) {
                const loadingPlaceholder = document.getElementById('loading-placeholder');
                if (loadingPlaceholder) {
                    loadingPlaceholder.innerHTML = '<p>This app seems empty!<br>Get started by adding the following code:</p><jt-internal-code body="Jt.text(&quot;Hello World!&quot;).use();" language="java"></jt-internal-code>';
                }
            }
        } else {
            alert(`Unknown message type ${message.type}. Please reach out to support.`);
        }
        if (window.javelit.isDevMode && message.toastDuration) {
            const toast = document.createElement('jt-internal-toast');
            toast.body = message.toastBody ? message.toastBody : "";
            toast.icon = message.toastIcon ? message.toastIcon : "";
            toast.duration = message.toastDuration;
            toast.position = "bottom"
            document.body.appendChild(toast);
        }
    }

    // Layout management
    const layoutContainers = new Map([
        ['main', mainContainer],
        ['sidebar', sidebarContainer] // Backend content goes to the inner container
    ]);

    // DOM mutation batching
    let pendingMutations = [];
    let mutationTimeout = null;
    let firstMutationTime = null;
    // mutations received at less than 4ms (~1 frame at 240fps) of space are batched together to avoid flickering
    // every time a mutation is received the 4ms time is reset ...
    const MUTATION_BATCH_WINDOW = 4;
    // ... so we set a hard limit to flush the batch of 16ms ~ 1 frame at 60fps
    // FIXME this means animation will only run at max 60fps (assuming 0 latency network) so we may want to make this value configurable
    //   in any case streamlit does not ensure constant frame rate because of the delivery via ws
    const MAX_BATCH_WAIT_TIME = 16;

    function createElementFromHTML(htmlString) {
        if (!htmlString) {
            return null;
        }
        const template = document.createElement('template');
        template.innerHTML = htmlString.trim();
        return template.content.firstChild;
    }

    function handleComponentRegistrations(registrations) {
        if (!registrations || registrations.length === 0) return;

        // Ensure a hidden container is present
        let container = document.getElementById('javelit-registrations');
        if (!container) {
            container = document.createElement('div');
            container.id = 'javelit-registrations';
            container.style.display = 'none';
            document.body.appendChild(container);
        }

        registrations.forEach((registration) => {
            // Parse the registration HTML safely
            const template = document.createElement('template');
            template.innerHTML = registration;
            const fragment = template.content;

            // Execute all <script> tags inside the fragment
            fragment.querySelectorAll('script').forEach((script) => {
                const newScript = document.createElement('script');
                if (script.type) newScript.type = script.type;
                if (script.src) {
                    newScript.src = script.src;
                } else {
                    newScript.textContent = script.textContent;
                }
                document.head.appendChild(newScript);
            });

            // Inject the rest of the HTML (custom elements etc.)
            container.appendChild(fragment);
        });
    }

    function handleDeltaMessage(message) {
        const {
            index = null,                 // null means append
            html,
            container,                       // should always be set
            clearBefore = false           // Default to no clearing
        } = message;

        // Clear initial "Connecting..." message on first delta
        if (isFirstDelta) {
            mainContainer.innerHTML = '';
            isFirstDelta = false;
        }

        // Close compilation modal since we're receiving successful deltas
        otherErrorModal.show = false;

        // Handle component registrations immediately
        handleComponentRegistrations(message.registrations);

        // Create element immediately (outside batch)
        const newElement = createElementFromHTML(html);

        // Queue DOM mutations
        pendingMutations.push({
            type: 'delta',
            index,
            element: newElement,
            container: container,
            clearBefore
        });

        // Track first mutation time
        if (!firstMutationTime) {
            firstMutationTime = Date.now();
        }

        // Check if we've waited too long
        const elapsed = Date.now() - firstMutationTime;
        if (elapsed >= MAX_BATCH_WAIT_TIME) {
            // Force immediate processing to prevent starvation
            if (mutationTimeout) {
                clearTimeout(mutationTimeout);
                mutationTimeout = null;
            }
            processMutations();
            firstMutationTime = null;
        } else {
            // Normal batch processing
            if (mutationTimeout) {
                clearTimeout(mutationTimeout);
            }

            mutationTimeout = setTimeout(() => {
                processMutations();
                mutationTimeout = null;
                firstMutationTime = null;
            }, MUTATION_BATCH_WINDOW);
        }
    }

    function processMutations() {
        if (pendingMutations.length === 0) return;

        requestAnimationFrame(() => {
            // Group mutations by container
            const mutationsByContainer = new Map();

            pendingMutations.forEach(mutation => {
                // Get target container for this container
                if (!mutationsByContainer.has(mutation.container)) {
                    mutationsByContainer.set(mutation.container, []);
                }
                mutationsByContainer.get(mutation.container).push(mutation);
            });

            // Process mutations for each container separately
            mutationsByContainer.forEach((mutations, container) => {
                const containerEl = document.querySelector(`[data-container="${container}"]`);
                if (!containerEl) {
                    // If all mutations are page resets (clearBefore=true and index=0), skip silently
                    // this can happen when a container is fully removed (eg because of a page change in a multipage app)
                    const allArePageResets = mutations.every(m => m.clearBefore === true && m.index === 0);
                    if (allArePageResets) {
                        return; // Skip this container
                    }
                    throw new Error(`Nested container not found for path: ${container}. Implementation error. Please reach out to support.`);
                }

                mutations.forEach(mutation => {
                    if (mutation.clearBefore && mutation.index !== null) {
                        while (containerEl.children.length > mutation.index) {
                            containerEl.removeChild(containerEl.lastChild);
                        }
                    }
                    // in the clearing case, it can happen that the element is null to trigger a full cleanup - so checking here but not below
                    if (mutation.element) {
                        if (mutation.index !== null && mutation.index < containerEl.children.length) {
                            containerEl.children[mutation.index].replaceWith(mutation.element);
                        } else {
                            containerEl.appendChild(mutation.element);
                        }
                    }
                });
            });

            pendingMutations = [];
        });
    }

    function handleModalErrorMessage(message) {
        document.getElementById('other-error-title').textContent = message.title;
        document.getElementById('other-error-paragraph').textContent = message.paragraph;

        // hotfix - the jt-internal-code component does not support body updates - recreating a new jt-internal-code manually
        const oldCodeElement = document.getElementById('other-error-code');
        if (oldCodeElement) {
            oldCodeElement.remove();
        }
        const newCodeElement = document.createElement('jt-internal-code');
        newCodeElement.id = 'other-error-code';
        newCodeElement.setAttribute('body', message.error);
        newCodeElement.setAttribute('language', 'language-none');

        // if the modal was already visible, apply animation to make change visible
        if (otherErrorModal.show === true) {
            newCodeElement.classList.add('error-updated');
            // Remove animation class after it completes
            setTimeout(() => {
                newCodeElement.classList.remove('error-updated');
            }, 1800); // Match animation duration (600ms × 3 loops)
        }

        otherErrorModal.appendChild(newCodeElement);

        // Set or remove prevent-close attribute based on message.closable
        if (message.closable === false) {
            otherErrorModal.setAttribute('prevent-close', '');
        } else {
            otherErrorModal.removeAttribute('prevent-close');
        }

        otherErrorModal.show = true;

    }

    // Settings management
    function applySettings(config) {
        if (config.appearance && config.appearance.wideMode !== undefined) {
            if (config.appearance.wideMode) {
                mainLayout.style.maxWidth = 'none';
            } else {
                mainLayout.style.maxWidth = '768px';
            }
        }
    }

    function loadAndApplySettings() {
        try {
            const stored = localStorage.getItem('javelit-settings');
            if (stored) {
                const config = JSON.parse(stored);
                applySettings(config);
            }
        } catch (e) {
            console.warn('Failed to load settings on startup:', e);
        }
    }

    // Listen for settings changes
    if (settingsContent) {
        settingsContent.addEventListener('config-change', (e) => {
            applySettings(e.detail.config);
        });
    }

    // Initialize sidebar, settings, and connection
    loadAndApplySettings();
    initializeSidebar();
    createWebSocketConnection();
</script>
</body>
</html>
