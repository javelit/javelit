{{!
    Copyright © 2025 Cyril de Catheu (cdecatheu@hey.com)

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
}}
<link rel="stylesheet" href="{{ MATERIAL_SYMBOLS_CDN }}">
<script src="{{ SPRINTF_DEPENDENCY }}"></script>
<script type="module">
    import { LitElement, html, css, unsafeHTML } from '{{ LIT_DEPENDENCY }}';

    class JtNumberInput extends LitElement {
        static styles = css`
            {{{ MARKDOWN_CSS }}}

            :host {
                display: block;
                margin: var(--jt-spacing-lg) 0;
            }

            :host([width]:not([width="stretch"])) {
                width: var(--input-width);
                max-width: 100%;
            }

            .input-container {
                display: flex;
                flex-direction: column;
                gap: var(--jt-spacing-xs);
            }

            .label-row {
                display: flex;
                align-items: center;
                gap: var(--jt-spacing-sm);
            }

            .label {
                font-family: var(--jt-font-family);
                font-size: var(--jt-font-size-sm);
                font-weight: var(--jt-font-weight-medium);
                color: var(--jt-text-primary);
                margin: 0;
            }

            .label.spacer {
                visibility: hidden;
            }

            .input-wrapper {
                position: relative;
                display: flex;
                flex-flow: row nowrap;
                align-items: center;
                background-color: rgb(240, 242, 246);
                border: 1px solid rgb(240, 242, 246);
                border-radius: var(--jt-border-radius);
                transition: border-color var(--jt-transition-fast), 
                           box-shadow var(--jt-transition-fast);
            }

            .input-wrapper:has(.input-field:focus) {
                border-color: var(--jt-theme-color);
                box-shadow: 0 0 0 1px var(--jt-theme-color);
            }

            .input-icon-wrapper {
                display: flex;
                align-items: center;
                justify-content: center;
                padding-left: var(--jt-spacing-md);
                flex-shrink: 0;
            }

            .input-field {
                flex: 1;
                box-sizing: border-box;
                padding: 0.75em var(--jt-spacing-sm) 0.75em var(--jt-spacing-lg);
                background: transparent;
                border: none;
                font-family: var(--jt-font-family);
                font-size: var(--jt-font-size-base);
                color: var(--jt-text-primary);
                outline: none;
                line-height: 1.2;
            }

            .input-field::placeholder {
                color: var(--jt-text-muted);
                opacity: 0.7;
            }

            .input-field:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .input-icon {
                display: flex;
                align-items: center;
                justify-content: center;
                pointer-events: none;
                color: var(--jt-text-muted);
            }

            .input-icon.material {
                font-family: 'Material Symbols Rounded';
                font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
                font-size: var(--jt-font-size-lg);
            }

            .input-icon.emoji {
                font-size: var(--jt-font-size-base);
            }

            :host([has-icon]) .input-field {
                padding-left: var(--jt-spacing-sm);
            }

            .step-controls {
                display: flex;
                gap: 0;
                flex-shrink: 0;
                align-items: stretch;
                align-self: stretch;
                overflow: hidden;
                border-radius: 0 var(--jt-border-radius) var(--jt-border-radius) 0;
            }

            .step-btn {
                width: 32px;
                border: none;
                background: transparent;
                color: var(--jt-text-primary);
                font-size: 1.2rem;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                user-select: none;
                transition: all var(--jt-transition-fast);
                outline: none;
                border-radius: 0;
            }

            .step-btn:hover:not(:disabled) {
                background-color: var(--jt-theme-color);
                color: var(--jt-text-white);
            }

            .step-btn:focus,
            .step-btn:active {
                background: var(--jt-theme-color);
                color: var(--jt-text-white);
            }

            .step-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .helper-text {
                position: absolute;
                bottom: 0.25em;
                right: 68px; /* Position to left of +/- buttons */
                display: flex;
                align-items: center;
                gap: 4px;
                font-family: var(--jt-font-family);
                font-size: 0.7rem;
                color: var(--jt-text-muted);
                pointer-events: none;
            }

            .enter-hint {
                opacity: 0;
                transition: opacity var(--jt-transition-fast);
            }

            .enter-hint.visible {
                opacity: 1;
            }
        `;

        static properties = {
            label: { type: String },
            value: { type: String },
            minValue: { type: String, attribute: 'min-value' },
            maxValue: { type: String, attribute: 'max-value' },
            step: { type: Number },
            format: { type: String },
            help: { type: String },
            placeholder: { type: String },
            disabled: { type: Boolean },
            labelVisibility: { type: String, attribute: 'label-visibility' },
            icon: { type: String },
            width: { type: String },
            componentKey: { type: String, attribute: 'component-key' },
            hasIcon: { type: Boolean, attribute: 'has-icon', reflect: true },
            hasChanged: { type: Boolean, state: true },
            isFocused: { type: Boolean, state: true }
        };

        constructor() {
            super();
            this.value = '';
            this.disabled = false;
            this.labelVisibility = 'visible';
            this.width = 'stretch';
            this.step = 1;
            
            // Internal state
            this.initialValue = '';
            this.hasChanged = false;
            this.isFocused = false;
        }

        connectedCallback() {
            super.connectedCallback();
            this.initialValue = this.value || '';
        }

        updated(changedProperties) {
            // Update width CSS variable
            if (changedProperties.has('width') && this.width && this.width !== 'stretch') {
                this.style.setProperty('--input-width', `${this.width}px`);
            } else if (this.width === 'stretch') {
                this.style.removeProperty('--input-width');
            }

            // Update icon state
            if (changedProperties.has('icon')) {
                this.hasIcon = !!this.icon;
            }

            // Reset initial value when value changes from backend
            if (changedProperties.has('value') && !this.hasChanged) {
                this.initialValue = this.value || '';
            }
        }


        isEmoji(str) {
            return str && str.length <= 2 && /\p{Emoji}/u.test(str);
        }

        isMaterialIcon(str) {
            return str && str.startsWith(':') && str.endsWith(':') && str.length > 2;
        }

        getMaterialIconName(str) {
            if (!this.isMaterialIcon(str)) return '';
            return str.slice(1, -1);  // Remove leading and trailing colons
        }

        formatDisplayValue(rawValue) {
            if (!rawValue && rawValue !== 0) return '';
            
            const numValue = parseFloat(rawValue);
            if (isNaN(numValue)) return rawValue;
            
            if (this.format && window.sprintf) {
                try {
                    return window.sprintf(this.format, numValue);
                } catch (e) {
                    console.warn('Invalid format string:', this.format);
                    return rawValue;
                }
            }
            
            return rawValue;
        }

        parseInputValue(strValue) {
            if (!strValue || strValue.trim() === '') return null;
            
            const trimmed = strValue.trim();
            const parsed = parseFloat(trimmed);
            return isNaN(parsed) ? null : parsed;
        }

        isValidNumberInput(char, currentValue, cursorPos) {
            // Allow basic number characters
            if (/[0-9]/.test(char)) return true;
            
            // Allow decimal point (only one)
            if (char === '.') {
                return currentValue.indexOf('.') === -1;
            }
            
            // Allow minus sign at start
            if (char === '-') {
                return cursorPos === 0 && currentValue.indexOf('-') === -1;
            }
            
            // Allow plus sign at start
            if (char === '+') {
                return cursorPos === 0 && currentValue.indexOf('+') === -1 && currentValue.indexOf('-') === -1;
            }
            
            // Allow scientific notation (e, E)
            if (/[eE]/.test(char)) {
                const hasE = /[eE]/.test(currentValue);
                return !hasE && currentValue.length > 0;
            }
            
            // Allow control characters
            if (char.length !== 1) return true;
            
            return false;
        }

        applyConstraints(value) {
            if (value === null || value === undefined) return null;
            
            let numValue = typeof value === 'number' ? value : parseFloat(value);
            if (isNaN(numValue)) return null;
            
            // Apply min constraint
            if (this.minValue !== null && this.minValue !== undefined) {
                const min = parseFloat(this.minValue);
                if (!isNaN(min) && numValue < min) {
                    numValue = min;
                }
            }
            
            // Apply max constraint
            if (this.maxValue !== null && this.maxValue !== undefined) {
                const max = parseFloat(this.maxValue);
                if (!isNaN(max) && numValue > max) {
                    numValue = max;
                }
            }
            
            return numValue;
        }

        handleKeyPress(e) {
            if (this.disabled) return;
            
            const char = e.key;
            const input = e.target;
            
            // Allow special keys (backspace, delete, arrow keys, etc.)
            if (e.metaKey || e.ctrlKey || char.length > 1) {
                return;
            }
            
            if (!this.isValidNumberInput(char, input.value, input.selectionStart)) {
                e.preventDefault();
            }
        }

        handleInput(e) {
            if (this.disabled) return;

            const newValue = e.target.value;
            
            // Track if value has changed from initial
            this.hasChanged = newValue !== this.initialValue;
            
            this.requestUpdate();
        }

        handleKeydown(e) {
            if (this.disabled) return;

            if (e.key === 'Enter') {
                e.preventDefault();
                this.submitValue();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                this.stepUp();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                this.stepDown();
            }
        }

        handleFocus() {
            this.isFocused = true;
            this.requestUpdate();
        }

        handleBlur() {
            this.isFocused = false;
            
            // Submit value if it has changed
            if (this.hasChanged) {
                this.submitValue();
            }
            
            this.requestUpdate();
        }

        stepUp() {
            if (this.disabled) return;
            
            const input = this.shadowRoot.querySelector('.input-field');
            let currentValue = this.parseInputValue(input.value);
            
            if (currentValue === null) {
                // If no current value, start from min or 0
                if (this.minValue !== null && this.minValue !== undefined) {
                    currentValue = parseFloat(this.minValue);
                } else {
                    currentValue = 0;
                }
            }
            
            const stepValue = this.step;
            const newValue = currentValue + stepValue;
            const constrainedValue = this.applyConstraints(newValue);
            
            if (constrainedValue !== null) {
                input.value = constrainedValue.toString();
                this.submitValue();
            }
        }

        stepDown() {
            if (this.disabled) return;
            
            const input = this.shadowRoot.querySelector('.input-field');
            let currentValue = this.parseInputValue(input.value);
            
            if (currentValue === null) {
                // If no current value, start from max or 0
                if (this.maxValue !== null && this.maxValue !== undefined) {
                    currentValue = parseFloat(this.maxValue);
                } else {
                    currentValue = 0;
                }
            }
            
            const stepValue = this.step;
            const newValue = currentValue - stepValue;
            const constrainedValue = this.applyConstraints(newValue);
            
            if (constrainedValue !== null) {
                input.value = constrainedValue.toString();
                this.submitValue();
            }
        }

        submitValue() {
            const input = this.shadowRoot.querySelector('.input-field');
            const currentValue = input.value;
            
            // Parse and validate the value
            const parsedValue = this.parseInputValue(currentValue);
            const constrainedValue = this.applyConstraints(parsedValue);
            
            // Update display if value was constrained
            if (constrainedValue !== parsedValue) {
                input.value = constrainedValue !== null ? constrainedValue.toString() : '';
            }
            
            // Update internal state
            this.value = input.value;
            this.initialValue = this.value;
            this.hasChanged = false;
            
            // Emit to backend
            window.javelit.sendComponentUpdate(this.componentKey, constrainedValue);
            
            this.requestUpdate();
        }

        areButtonsDisabled() {
            const input = this.shadowRoot?.querySelector('.input-field');
            const inputValue = input?.value || this.value;
            
            // Disable if component is disabled or if value is null/empty initially
            return this.disabled || (!inputValue && !this.value);
        }

        render() {
            const showEnterHint = this.hasChanged && this.isFocused;
            const displayValue = this.formatDisplayValue(this.value) || '';
            const buttonsDisabled = this.areButtonsDisabled();

            let iconElement = null;
            if (this.icon) {
                if (this.isEmoji(this.icon)) {
                    iconElement = html`<span class="input-icon emoji">${this.icon}</span>`;
                } else if (this.isMaterialIcon(this.icon)) {
                    iconElement = html`<span class="input-icon material">${this.getMaterialIconName(this.icon)}</span>`;
                }
            }

            return html`
                <div class="input-container">
                    <div class="label-row">
                        ${this.labelVisibility !== 'collapsed' ? html`
                            <div class="label ${this.labelVisibility === 'hidden' ? 'spacer' : ''}">
                                ${this.labelVisibility === 'hidden' ? html`&nbsp;` : html`<div class="markdown-content">${unsafeHTML(this.label)}</div>`}
                            </div>
                        ` : ''}
                        ${this.help && this.labelVisibility === 'visible' ? html`
                            <jt-tooltip text="${this.help}"></jt-tooltip>
                        ` : ''}
                    </div>
                    
                    <div class="input-wrapper">
                        <div class="input-icon-wrapper">
                            ${iconElement}
                        </div>
                        <input
                            class="input-field"
                            type="text"
                            .value="${displayValue}"
                            placeholder="${this.placeholder || ''}"
                            ?disabled="${this.disabled}"
                            @keypress="${this.handleKeyPress}"
                            @input="${this.handleInput}"
                            @keydown="${this.handleKeydown}"
                            @focus="${this.handleFocus}"
                            @blur="${this.handleBlur}"
                        />
                        <div class="step-controls">
                            <button
                                    class="step-btn step-down"
                                    ?disabled="${buttonsDisabled}"
                                    @click="${this.stepDown}"
                                    tabindex="-1"
                            >–</button>
                            <button 
                                class="step-btn step-up"
                                ?disabled="${buttonsDisabled}"
                                @click="${this.stepUp}"
                                tabindex="-1"
                            >+</button>
                        </div>
                        
                        <div class="helper-text">
                            ${showEnterHint ? html`
                                <span class="enter-hint ${showEnterHint ? 'visible' : ''}">
                                    Press enter to apply
                                </span>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }
    }

    customElements.define('jt-number-input', JtNumberInput);
</script>
